#title: 对象生命范围
#index:0,1
#author: zozoh(zozohtnt@gmail.com)
------------------------------------------------------------------------------------------------
高级接口容器接口
	
	NutIoc 实现了 Ioc2 接口，它继承自 Ioc 接口，并多出了两个方法。
	一个允许你自行添加自定义的值类型，另一个是允许你在获取对象时，链入自己的上下文环境

	请阅读 org.nutz.ioc.IocContext 的接口文档， 你可以根据需要实现这个上下文接口
------------------------------------------------------------------------------------------------
这个设计有什么用？

	比如，在一个 Web 应用中，你希望在会话中保存一个数据源，你不希望这个数据源保存在 Application
	级别里。因为，只有当用户登录的时候，你才能确定你到底要连接哪个数据源。
	
	那么，在配置文件中，我的那个数据源对象，以及所有引用它的对象，都会声明了 scope : "session"。
	每次启动一个会话，我们就创建一个 Session 的上下文，当请求发生时，就用通过 Ioc2 来获取对象
	--- 传入 session 上下文。 当会话停止时，会注销这个上下文，那么保存在里面的数据源也会彻底关闭
	
	如果没有 Ioc2 这个接口，则做不到这一点
------------------------------------------------------------------------------------------------
通过 ComboContext 链接
	
	在 org.ioc.impl.NutIoc 里，默认有一个 IocContext，它的 scope 是 "app"。

	每次从 NutIoc 里获取对象，如果你想告诉容器：“嘿，我还有另外的一个缓存，请优先在里面查查”
	你可以这样调用：
	{{{
	IocContext myCache = ...;  // 获取你的缓存
	MyObject obj = ioc.get(MyObjec.class, "objName", myCache);
	}}}

	Nutz.Ioc 默认提供了两个 IocContext:
	 * ScopeContext： 顾名思义，它只表示某一个指定的声明周期范围
		 * 在其构造函数里，你必须指明这个上下文对象可以接受的生命周期范围的名称
		 * 当你的配置信息中 scope 一项同它的范围名称完全匹配时，它会接受你的对象
	 * ComboContext：它可以把多个 IocContext 集合成一个 IocContext
		 * 通过它，你可以一次向多个 IocContext 获取或者存入对象