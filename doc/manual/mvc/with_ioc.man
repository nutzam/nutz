#title: 同 Ioc 容器一起工作
#index:0,1
#author: zozoh(zozohtnt@gmail.com)
-----------------------------------------------------------------------------------------------------------------------
内置的 Ioc 容器
	
	一个 Mvc 框架可以通过 Ioc 接口同一个 Ioc 容器挂接，挂接的方法很简单： 在主模块上声明 @IocBy
	{{{
	@IocBy(type=ComboIocProvider.class, args={"*js", "ioc/",
										   "*anno", "net.wendal.nutzbook",
										   "*async",
										   "*tx"
										   })
	public class MainModule {
		...
	}}}
	
	推荐使用ComboIocProvider,组合使用各种IocLoader. 详细用法请参考[../ioc/loader_combo.man Ioc复合加载器]

-----------------------------------------------------------------------------------------------------------------------
由 Ioc 容器管理子模块
	
	如果声明了@IocBean,那么 @InjectName是不需要的,且无效的!!
	
	通过 @IocBy 为整个应用声明了 Ioc 容器，那么如何使用呢。 实际上，你的每一个模块都可以来自容器，只要
	你在模块上声明 @InjectName。 当然，在主模块声明这个注解是没有意义的。

	{{{
	@InjectName("petM")
	public class PetModule {
	   ...
	}}}

	 * 如果你声明了这个注解， Nutz.Mvc 构造你的这个模块的时候，会通过 Ioc 容器获取，而不直接调用默认构造函数了。
	 * 如果你的 '@InjectName' 并没有值，那么默认会将你的模块类名首字母小写作为模块的注入名
	 	 * 比如上例，你直接声明 '@InjectName' 同 '@InjectName("petModule")' 是等效的
	
-----------------------------------------------------------------------------------------------------------------------
在容器对象里获得 ServletContext

	别注入了,直接拿

	{{{
	Mvcs.getServletContext();
	}}}
	
-----------------------------------------------------------------------------------------------------------------------
自定 Ioc 容器
	
	你很喜欢 Spring，或者你很喜欢 Guice。不管怎么说，你不想用 Nutz.Ioc，那么没关系，你可以自己实现一个 IocProvider。
	并用 @IocBy 声明到整个应用中即可。通过 Spring 或者 Guice 实现 Ioc 接口想必不是什么难事。
	
