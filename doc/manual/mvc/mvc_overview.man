#title:Nutz.Mvc 概述
#index:0,1

几句话的介绍

	Nutz.Mvc 是要和一个 Web 服务器 （比如 Tomcat）一起工作的，它存在的意义{*就是要把一个标准的 HTTP 请求，转发到某一个 Java 函数中}。
	
	它的特点是：
	 * 帮你做参数的解析 （{/当然你自己可以随意扩展}）
	 * 如果你愿意，你可以不用 View 来渲染 HTTP 输出流
	 * 提供几个基本的渲染方式 （比如 JSP, JSON）
	 * 除此以外，不内置更多的功能

	每一种 HTTP 请求，标识就是一个 URL，而每一个 Java 函数怎样和一个 URL 关联呢？ 最直接的办法就是在函数上声明一个
	注解，这个注解，在 Nutz.Mvc 中，叫 @At
	
	你如果想快速开始，来一个 Hellow World， 那么请访问 [http://nutzdemo.googlecode.com]，上面的 Hello Mvc 是完全可以运行的

图解 Nutz.Mvc

	为了能让你更快速直观的了解 Nutz.Mvc 的工作方式，我提供下面两张图：
	
	每一次请求，都经过如下流程
		
		<nutz_mvc_workflow_overview.png>
		
		Nutz.Mvc 根据 @At 注解，将一个 HTTP 请求映射到了一个函数，函数只有一个参数，会被路径参数 （1045） 填充。
		 * Nutz.Mvc 最基本的想法，就是通过注解 @At 将一个HTTP请求路径同一个 Java 函数关联起来。
		 * 并且，@At 支持你写多个路径
		
	更详细的流程

		<nutz_mvc_workflow_detail.png>
		
		 * 声明了 @At 的函数被称为 {*入口函数}
		 * 任何一个请求，都会经过四道工序
			 # {*A} - {*过滤}: 你通过 @Filters 注解可以为你的{*入口函数}定义任意多的过滤器
			 # {*B} - {*适配}: 这个过程将 HTTP 输入流转换成{*入口函数}的参数数组
				 * 默认的，它认为输入流是传统的名值对方式
				 * 更多的适配方式请参看 [mvc_http_adaptor.man 关于适配器]
				 * 文件上传也是一种适配方式，请参看 UploadAdptor
			 # {*C} - {*调用}: 调用{*入口函数}，你在里面需要调用相关的业务层代码。
				 * 如果你的业务比较复杂，为了解耦合，你可能需要 Ioc 容器的帮助，请参看 [mvc_ioc.man 同 Ioc 容器一起工作] 一节
			 # {*D} - {*渲染}: 根据{*入口函数}的返回，渲染 HTTP Response。
				 * 如果返回是个 View，则用这个 View 来渲染 null （null? 是的，你没看错，这种情况 View 接口第三个参数会是 null）
					 * 你可以用 org.nutz.mvc.view.ViewWrapper 将你的返回对象以及要返回的视图组合在一起返回，ViewWrapper 也是一个 View
				 * 否则用函数的 @Ok 注解声明的 View 来渲染{*入口函数}的返回对象
				 * 如果你的函数处理过程中抛出了异常，用 @Error 注解声明的 View 来渲染异常对象
	

你还需要知道	
	关于 @At
		 * 声明了这个注解的函数就是{*入口函数}
		 * 可以一次声明多个 URL，比如：
			{{{
			@At({"/fetch","/get"})
			public Pet fetch(int petId){
				...
			}}}
		 * 它不仅可以声明在函数上，它也可以声明在模块类上
			 * 如果声明在模块上，模块上所有的{*入口函数}的 URL 实际上都会被加上一个前缀
			 * 如果不声明值，默认值为模块类名的小写形式

	通过 web.xml 挂接在 Jsp/Servlet 容器中
		同大多数单纯的 Mvc 框架一样， Nutz.Mvc 也提供了一个 Servlet 作为同 JSP/Servlet 容器的挂载点。
		{{{<web.xml>
		<web-app>
			<servlet>
				<servlet-name>nutz</servlet-name>
				<servlet-class>org.nutz.mvc.NutServlet</servlet-class>
				<init-param>
					<param-name>modules</param-name>
					<param-value>nutz.demo.mvc.MainModule</param-value>
				</init-param>
				<load-on-startup>1</load-on-startup>
			</servlet>

			<servlet-mapping>
				<servlet-name>nutz</servlet-name>
				<url-pattern>*.nut</url-pattern>
			</servlet-mapping>
		</web-app>
		}}}
		 * NutServlet 只需要一个参数 -- 一个类的全名。这个将被认为是{*主模块}
		 * 在这个类上你可以声明注解
			 * 通过 '@Modules' 注解声明整个应用有哪些{*子模块}
				 * {*子模块}不能再嵌套{*子模块}
			 * 通过 '@IocBy' 注解声明整个应用，应采用何种方式进行反转注入。如果没有声明，整个应用将不支持 Ioc 
			 * 通过 '@Localization' 注解声明整个应用的本地地化字符串的目录
			 * 通过 '@SetupBy' 注解声明应用启动的关闭时，应该进行的处理。
			 * 通过 '@Views' 注解扩展整个应用支持的视图模板类型
			 * 通过 '@Ok' 注解声明整个应用默认的成功视图
			 * 通过 '@Fail' 注解声明整个应用默认的失败视图
			 * 通过 '@AdaptBy' 注解声明整个应用默认的 HTTP 参数适配方式
			 * 通过 '@Filters' 注解声明整个应用默认的过滤器数组
			 * 通过 '@Encoding' 注解声明整个应用默认的输入输出字符编码

	如何将函数参数和 HTTP 参数对应起来
		 * 这个过程被称为适配，执行这个过程的类需要实现 org.nutz.mvc.HttpAdaptor 接口
		 * 通过 @AdaptBy 注解，可以为每个{*子模块}声明默认的适配方式
			 * 这个注解也可是直接声明在{*入口函数}上
		 * [mvc_http_adaptor.man 关于适配器] 一节有更多的描述
		 * 默认的，Nutz.Mvc 将为你的{*入口函数}应用 org.nutz.mvc.adaptor.PairAdaptor

	你可以在入口函数上声明什么注解
		 * @At : 函数对应的 URL
		 * @Encoding : HTTP 请求的输入输出字符编码
		 * @Filters ： 函数的过滤器数组
		 * @AdaptBy ： 参数适配方式
		 * @Ok ： 成功渲染方式  -- 请参看 [mvc_view.man 关于视图]
		 * @Fail ： 异常渲染方式  -- 请参看 [mvc_view.man 关于视图]

	在子模块可以声明什么注解
		 * @InjectName ： Ioc 容器中，本模块对应的名称
		 * @At : 模块所有{*入口函数}的 URL 前缀
		 * @Encoding : 模块所有{*入口函数}默认的输入输出字符编码
		 * @Filters ： 模块所有{*入口函数}默认的函数的过滤器数组
		 * @AdaptBy ： 模块所有{*入口函数}默认的参数适配方式
		 * @Ok ： 模块所有{*入口函数}默认的如果成功渲染方式
		 * @Fail ： 模块所有{*入口函数}默认的异常渲染方式

	


